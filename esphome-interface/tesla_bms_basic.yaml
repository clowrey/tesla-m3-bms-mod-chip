esphome:
  name: tesla_bms_display
  friendly_name: Tesla BMS Display

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino

# Enable logging
logger:
  level: INFO
  logs:
    uart: DEBUG

# WiFi configuration
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Tesla_BMS_Display_AP"
    password: "12345678"

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key

# Enable OTA updates
ota:
  platform: esphome
  password: !secret ota_password

# Enable web server
web_server:
  port: 80

# Time component for timestamps
time:
  - platform: sntp
    id: sntp_time

# UART for communication with Tesla BMS
uart:
  - id: tesla_bms_uart
    tx_pin: GPIO17
    rx_pin: GPIO16
    baud_rate: 115200
    data_bits: 8
    parity: NONE
    stop_bits: 1

# Binary sensors for system status
binary_sensor:
  - platform: status
    name: "Tesla BMS Display Status"
    id: display_status

# Sensors for system parameters
sensor:
  # System parameters
  - platform: template
    name: "Number of BMBs"
    id: numbmbs
    unit_of_measurement: "boards"
    accuracy_decimals: 0
    
  - platform: template
    name: "Loop Counter"
    id: loopcnt
    unit_of_measurement: "count"
    accuracy_decimals: 0
    
  - platform: template
    name: "Loop State"
    id: loopstate
    unit_of_measurement: "state"
    accuracy_decimals: 0
    
  - platform: template
    name: "Cells Present"
    id: cellspresent
    unit_of_measurement: "cells"
    accuracy_decimals: 0
    
  - platform: template
    name: "Cells Balancing"
    id: cellsbalancing
    unit_of_measurement: "cells"
    accuracy_decimals: 0

  # Voltage statistics
  - platform: template
    name: "Cell Max Number"
    id: cellmax
    unit_of_measurement: "cell"
    accuracy_decimals: 0
    
  - platform: template
    name: "Cell Min Number"
    id: cellmin
    unit_of_measurement: "cell"
    accuracy_decimals: 0
    
  - platform: template
    name: "Max Voltage"
    id: umax
    unit_of_measurement: "mV"
    accuracy_decimals: 0
    
  - platform: template
    name: "Min Voltage"
    id: umin
    unit_of_measurement: "mV"
    accuracy_decimals: 0
    
  - platform: template
    name: "Voltage Delta"
    id: deltav
    unit_of_measurement: "mV"
    accuracy_decimals: 0

  # Balance control
  - platform: template
    name: "Balance Status"
    id: balance
    unit_of_measurement: "status"
    accuracy_decimals: 0

  # Temperature parameters
  - platform: template
    name: "Chip Temperature"
    id: chipt0
    unit_of_measurement: "Â°C"
    accuracy_decimals: 1

# Switches for control
switch:
  - platform: template
    name: "Balance Control"
    id: balance_control
    optimistic: true
    restore_state: false

# Buttons for manual control
button:
  - platform: template
    name: "Refresh Parameters"
    id: refresh_params
    on_press:
      - uart.write:
          id: tesla_bms_uart
          data: "param list\n"
      
  - platform: template
    name: "Enable Balance"
    id: enable_balance
    on_press:
      - uart.write:
          id: tesla_bms_uart
          data: "balance on\n"
      
  - platform: template
    name: "Disable Balance"
    id: disable_balance
    on_press:
      - uart.write:
          id: tesla_bms_uart
          data: "balance off\n"

# UART text sensor for parsing responses
text_sensor:
  - platform: uart
    id: tesla_bms_response
    uart_id: tesla_bms_uart
    name: "Tesla BMS Response"
    on_value:
      then:
        - lambda: |-
            // Parse parameter responses
            std::string response = x.c_str();
            
            // Check for balance status
            if (response.find("Balance ENABLED") != std::string::npos) {
              id(balance).publish_state(1.0f);
            } else if (response.find("Balance DISABLED") != std::string::npos) {
              id(balance).publish_state(0.0f);
            }
            
            // Parse parameter lines (format: "param_name: value")
            size_t colon_pos = response.find(':');
            if (colon_pos != std::string::npos) {
              std::string param_name = response.substr(0, colon_pos);
              std::string value_str = response.substr(colon_pos + 1);
              
              // Trim whitespace
              param_name.erase(0, param_name.find_first_not_of(" \t"));
              param_name.erase(param_name.find_last_not_of(" \t") + 1);
              value_str.erase(0, value_str.find_first_not_of(" \t"));
              value_str.erase(value_str.find_last_not_of(" \t") + 1);
              
              // Convert to float and update appropriate sensor
              float value = atof(value_str.c_str());
              
              // Map parameter names to sensor IDs
              if (param_name == "numbmbs") id(numbmbs).publish_state(value);
              else if (param_name == "LoopCnt") id(loopcnt).publish_state(value);
              else if (param_name == "LoopState") id(loopstate).publish_state(value);
              else if (param_name == "CellsPresent") id(cellspresent).publish_state(value);
              else if (param_name == "CellsBalancing") id(cellsbalancing).publish_state(value);
              else if (param_name == "CellMax") id(cellmax).publish_state(value);
              else if (param_name == "CellMin") id(cellmin).publish_state(value);
              else if (param_name == "umax") id(umax).publish_state(value);
              else if (param_name == "umin") id(umin).publish_state(value);
              else if (param_name == "deltaV") id(deltav).publish_state(value);
              else if (param_name == "Chipt0") id(chipt0).publish_state(value);
              
              // Handle cell voltages (u1-u108) - simplified for now
              else if (param_name.substr(0, 1) == "u" && param_name.length() <= 4) {
                // For now, just log cell voltages
                ESP_LOGD("TeslaBMS", "Cell %s: %.0f mV", param_name.c_str(), value);
              }
            }

# Interval to periodically request parameters
interval:
  - interval: 5s
    then:
      - uart.write:
          id: tesla_bms_uart
          data: "param list\n"

# Automation for balance control
automation:
  - trigger:
      platform: sensor
      id: balance
    action:
      - switch.turn_on: balance_control
        if:
          condition:
            sensor.numeric_state:
              id: balance
              above: 0.5
      - switch.turn_off: balance_control
        if:
          condition:
            sensor.numeric_state:
              id: balance
              below: 0.5 