esphome:
  name: tesla_bms_display
  friendly_name: Tesla BMS Display
  min_version: 2024.11.0
  on_boot:
    priority: 800.0
    then:
      - lambda: |-
          // Test display with a simple message
          lv_label_set_text((lv_obj_t*)id(label_title), "Display Test - Working!");
          lv_label_set_text((lv_obj_t*)id(label_cells), "Backlight: ON");
          lv_label_set_text((lv_obj_t*)id(label_balance), "Status: OK");
          ESP_LOGI("DISPLAY", "Display labels updated");

esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  flash_size: 16MB
  framework:
    type: esp-idf
    sdkconfig_options:
      COMPILER_OPTIMIZATION_SIZE: y
      CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: "y"
      CONFIG_ESP32S3_DATA_CACHE_64KB: "y"
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: "y"
      CONFIG_SPIRAM_FETCH_INSTRUCTIONS: y
      CONFIG_SPIRAM_RODATA: y

preferences:
  flash_write_interval: 1min

external_components:
  - source: ./external_components/tesla_bms_uart
  - source: github://pr#8553
    components: [axs15231]
    refresh: 1h

# Include individual cell voltage sensors
packages:
  cell_voltages: !include cell_voltage_sensors.yaml

psram:
  mode: octal
  speed: 80MHz

# Enable logging
logger:
  level: INFO
  hardware_uart: USB_SERIAL_JTAG

# WiFi configuration
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  reboot_timeout: 0s
  ap:
    ssid: "Tesla_BMS_Display_AP"
    password: "12345678"

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key
  reboot_timeout: 0s

# Enable OTA updates
ota:
  platform: esphome
  password: !secret ota_password

# Enable web server
web_server:
  port: 80
  version: 3

# Time component for timestamps
time:
  - platform: sntp
    id: sntp_time

# UART for communication with Tesla BMS
uart:
  id: tesla_bms_uart_uart
  tx_pin: GPIO43
  rx_pin: GPIO44
  baud_rate: 115200
  data_bits: 8
  parity: NONE
  stop_bits: 1

# Global variables to store UART buffer
globals:
  - id: uart_buffer
    type: std::string
    restore_value: no
    initial_value: '""'
  - id: cell_bars_created
    type: bool
    restore_value: no
    initial_value: 'false'
  # Alternative: Parameter request queue for more sophisticated control
  # - id: param_request_queue
  #   type: std::vector<std::string>
  #   restore_value: no
  # - id: current_param_index
  #   type: int
  #   restore_value: no
  #   initial_value: '0'

# Display backlight control
output:
  - platform: ledc 
    pin: GPIO1
    id: backlight
    frequency: "1000Hz"

light:
  - platform: monochromatic
    output: backlight
    name: Display Backlight
    id: display_backlight
    restore_mode: ALWAYS_ON

i2c:
  sda: 4
  scl: 8
  id: touchscreen_bus

touchscreen:
  - platform: axs15231
    id: my_touchscreen
    display: my_display
    i2c_id: touchscreen_bus
    calibration:
      x_min: 0
      x_max: 480
      y_min: 0
      y_max: 320
    transform:
      swap_xy: true
      mirror_x: true
      mirror_y: false
    on_touch:
      - lambda: |-
          ESP_LOGI("cal", "x=%d, y=%d, x_raw=%d, y_raw=%0d",
            touch.x,
            touch.y,
            touch.x_raw,
            touch.y_raw
          );

# QSPI Display (matching ESPHome EVSE configuration)
spi:
  id: display_qspi
  type: quad
  clk_pin: 47
  data_pins: [21, 48, 40, 39]

display:
  - platform: qspi_dbi
    model: JC4832W535
    data_rate: 40MHz
    id: my_display
    spi_id: display_qspi
    dimensions:
      height: 480
      width: 320
    cs_pin:
      number: 45
      ignore_strapping_warning: true
    rotation: 270
    auto_clear_enabled: false

# LVGL interface
lvgl:
  displays:
    - my_display
  touchscreens:
    - my_touchscreen
  page_wrap: true
  theme:
    obj:
      border_width: 0
      pad_all: 0
      bg_color: 0
      text_color: white
      scrollable: false
    label:
      border_width: 0
      scrollable: false
    button:
      text_font: montserrat_14
      scroll_on_focus: true
      radius: 10px
      shadow_width: 0
      checked:
        bg_color: green
        text_color: white

# Main Page
  pages:
    - id: main_page
      height: 320
      width: 480
      text_font: montserrat_14
      scrollable: false
      text_color: white
      bg_color: 0
      bg_opa: COVER
      radius: 0
      pad_all: 5
      widgets:
        - obj:
            align: LEFT_MID
            width: 480
            height: 320
            pad_all: 5
            layout:
              pad_column: 5
              type: GRID
              grid_rows: [FR(40), FR(40), FR(40), FR(40), FR(40), FR(40), FR(40)]
              grid_columns: [FR(240), FR(240)]
            widgets:
              - label:
                  grid_cell_column_pos: 0
                  grid_cell_row_pos: 0
                  grid_cell_column_span: 2
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: label_title
                  align: CENTER
                  text: "M3Y BMS MOD Interface"
                  text_color: white
              - label:
                  grid_cell_column_pos: 0
                  grid_cell_row_pos: 1
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: label_cells
                  align: LEFT_MID
                  text: "Cells: 0/0"
                  text_color: white
              - label:
                  grid_cell_column_pos: 1
                  grid_cell_row_pos: 1
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: label_balance
                  align: RIGHT_MID
                  text: "Balance: OFF"
                  text_color: red
              - label:
                  grid_cell_column_pos: 0
                  grid_cell_row_pos: 2
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: label_max_voltage
                  align: LEFT_MID
                  text: "Max: 0.000V (Cell 0)"
                  text_color: white
              - label:
                  grid_cell_column_pos: 1
                  grid_cell_row_pos: 2
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: label_min_voltage
                  align: RIGHT_MID
                  text: "Min: 0.000V (Cell 0)"
                  text_color: white
              - label:
                  grid_cell_column_pos: 0
                  grid_cell_row_pos: 3
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: label_delta
                  align: LEFT_MID
                  text: "Delta: 0.000V"
                  text_color: white
              - label:
                  grid_cell_column_pos: 1
                  grid_cell_row_pos: 3
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: label_temp
                  align: RIGHT_MID
                  text: "Temp: 0.0°C"
                  text_color: white
              - label:
                  grid_cell_column_pos: 0
                  grid_cell_row_pos: 4
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: label_loop
                  align: LEFT_MID
                  text: "Loop: 0 (State: 0)"
                  text_color: white
              - label:
                  grid_cell_column_pos: 1
                  grid_cell_row_pos: 4
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: label_connected
                  align: RIGHT_MID
                  text: "Connected: No"
                  text_color: red
              - button:
                  grid_cell_column_pos: 0
                  grid_cell_row_pos: 5
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: btn_balance_on
                  bg_color: grey
                  widgets:
                    - label:
                        align: CENTER
                        text: "Balance ON"
                        text_color: white
                  on_short_click:
                    - uart.write:
                        id: tesla_bms_uart_uart
                        data: "balance on\n"
              - button:
                  grid_cell_column_pos: 1
                  grid_cell_row_pos: 5
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: btn_balance_off
                  bg_color: grey
                  widgets:
                    - label:
                        align: CENTER
                        text: "Balance OFF"
                        text_color: white
                  on_short_click:
                    - uart.write:
                        id: tesla_bms_uart_uart
                        data: "balance off\n"
              - button:
                  grid_cell_column_pos: 0
                  grid_cell_row_pos: 6
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: btn_next_page
                  bg_color: 0x003366
                  widgets:
                    - label:
                        align: CENTER
                        text: "Details >"
                        text_color: white
                  on_short_click:
                    - lvgl.page.next:
              - label:
                  grid_cell_column_pos: 1
                  grid_cell_row_pos: 6
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: label_time
                  align: CENTER
                  text: "00:00:00"
                  text_color: white

    # Battery Details Page
    - id: details_page
      height: 320
      width: 480
      text_font: montserrat_14
      scrollable: false
      text_color: white
      bg_color: 0
      bg_opa: COVER
      radius: 0
      pad_all: 5
      widgets:
        - obj:
            align: LEFT_MID
            width: 480
            height: 320
            pad_all: 5
            layout:
              pad_column: 5
              type: GRID
              grid_rows: [FR(35), FR(35), FR(35), FR(35), FR(35), FR(35), FR(35), FR(35)]
              grid_columns: [FR(240), FR(240)]
            widgets:
              - label:
                  grid_cell_column_pos: 0
                  grid_cell_row_pos: 0
                  grid_cell_column_span: 2
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: label_details_title
                  align: CENTER
                  text: "Battery Details"
                  text_color: 0x00CCFF
              - label:
                  grid_cell_column_pos: 0
                  grid_cell_row_pos: 1
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: label_avg_voltage
                  align: LEFT_MID
                  text: "Avg: 0.000V"
                  text_color: white
              - label:
                  grid_cell_column_pos: 1
                  grid_cell_row_pos: 1
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: label_dc_voltage
                  align: RIGHT_MID
                  text: "DC: 0.00V"
                  text_color: white
              - label:
                  grid_cell_column_pos: 0
                  grid_cell_row_pos: 2
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: label_cells_present
                  align: LEFT_MID
                  text: "Cells: 0"
                  text_color: white
              - label:
                  grid_cell_column_pos: 1
                  grid_cell_row_pos: 2
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: label_cells_balancing
                  align: RIGHT_MID
                  text: "Balancing: 0"
                  text_color: white
              - label:
                  grid_cell_column_pos: 0
                  grid_cell_row_pos: 3
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: label_chip_temp
                  align: LEFT_MID
                  text: "Chip: --°C"
                  text_color: white
              - label:
                  grid_cell_column_pos: 1
                  grid_cell_row_pos: 3
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: label_cell_temp0
                  align: RIGHT_MID
                  text: "Cell0: --°C"
                  text_color: white
              - label:
                  grid_cell_column_pos: 0
                  grid_cell_row_pos: 4
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: label_cell_temp1
                  align: LEFT_MID
                  text: "Cell1: --°C"
                  text_color: white
              - label:
                  grid_cell_column_pos: 1
                  grid_cell_row_pos: 4
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: label_temp_range
                  align: RIGHT_MID
                  text: "Range: --°C"
                  text_color: white
              - label:
                  grid_cell_column_pos: 0
                  grid_cell_row_pos: 5
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: label_bmb_count
                  align: LEFT_MID
                  text: "BMBs: 0"
                  text_color: white
              - label:
                  grid_cell_column_pos: 1
                  grid_cell_row_pos: 5
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: label_loop_details
                  align: RIGHT_MID
                  text: "Loop: 0"
                  text_color: white
              - label:
                  grid_cell_column_pos: 0
                  grid_cell_row_pos: 6
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: label_balance_status
                  align: LEFT_MID
                  text: "Balance: OFF"
                  text_color: red
              - label:
                  grid_cell_column_pos: 1
                  grid_cell_row_pos: 6
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: label_system_status
                  align: RIGHT_MID
                  text: "State: 0"
                  text_color: white
              - button:
                  grid_cell_column_pos: 0
                  grid_cell_row_pos: 7
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: btn_prev_page
                  bg_color: 0x003366
                  widgets:
                    - label:
                        align: CENTER
                        text: "< Back"
                        text_color: white
                  on_short_click:
                    - lvgl.page.previous:
              - button:
                  grid_cell_column_pos: 1
                  grid_cell_row_pos: 7
                  grid_cell_x_align: STRETCH
                  grid_cell_y_align: STRETCH
                  id: btn_cells_page
                  bg_color: 0x336600
                  widgets:
                    - label:
                        align: CENTER
                        text: "Cells >"
                        text_color: white
                  on_short_click:
                    - lvgl.page.next:

    # Cell Voltages Graph Page
    - id: cells_page
      height: 320
      width: 480
      text_font: montserrat_14
      scrollable: false
      text_color: white
      bg_color: 0
      bg_opa: COVER
      radius: 0
      pad_all: 5
      widgets:
        # Title and scale labels
        - label:
            align: TOP_MID
            x: 0
            y: 5
            text: "Cell Voltages (V)"
            text_color: 0x00CCFF
        - label:
            align: TOP_LEFT
            x: 10
            y: 25
            text: "4.2"
            text_color: 0xFF6666
        - label:
            align: TOP_LEFT
            x: 10
            y: 85
            text: "3.8"
            text_color: white
        - label:
            align: TOP_LEFT
            x: 10
            y: 145
            text: "3.4"
            text_color: white
        - label:
            align: TOP_LEFT
            x: 10
            y: 205
            text: "3.0"
            text_color: 0x6666FF
        # Grid lines for reference
        - obj:
            align: TOP_LEFT
            x: 35
            y: 35
            width: 440
            height: 1
            bg_color: 0xFF6666
            bg_opa: 50%
        - obj:
            align: TOP_LEFT
            x: 35
            y: 95
            width: 440
            height: 1
            bg_color: white
            bg_opa: 30%
        - obj:
            align: TOP_LEFT
            x: 35
            y: 155
            width: 440
            height: 1
            bg_color: white
            bg_opa: 30%
        - obj:
            align: TOP_LEFT
            x: 35
            y: 215
            width: 440
            height: 1
            bg_color: 0x6666FF
            bg_opa: 50%
        # Cell voltage bars container
        - obj:
            id: cells_container
            align: TOP_LEFT
            x: 35
            y: 35
            width: 440
            height: 180
            bg_opa: 0
            border_width: 0
            pad_all: 0
        # Navigation and info
        - button:
            align: BOTTOM_LEFT
            x: 5
            y: -5
            width: 100
            height: 30
            id: btn_back_to_details
            bg_color: 0x003366
            widgets:
              - label:
                  align: CENTER
                  text: "< Details"
                  text_color: white
            on_short_click:
              - lvgl.page.previous:
        - label:
            align: BOTTOM_MID
            x: 0
            y: -5
            id: label_cells_info
            text: "All 108 Cells (Real BMS Data)"
            text_color: white
        - label:
            align: BOTTOM_RIGHT
            x: -5
            y: -5
            id: label_cells_time
            text: "00:00:00"
            text_color: white
        
        # Color Legend/Index
        - label:
            align: BOTTOM_LEFT
            x: 110
            y: -25
            text: "Colors:"
            text_color: white
        - obj:
            align: BOTTOM_LEFT
            x: 160
            y: -30
            width: 8
            height: 8
            bg_color: 0xFF0000
            bg_opa: COVER
            border_width: 0
            radius: 0
        - label:
            align: BOTTOM_LEFT
            x: 172
            y: -25
            text: ">4.1V"
            text_color: 0xFF6666
        - obj:
            align: BOTTOM_LEFT
            x: 210
            y: -30
            width: 8
            height: 8
            bg_color: 0xFFFF00
            bg_opa: COVER
            border_width: 0
            radius: 0
        - label:
            align: BOTTOM_LEFT
            x: 222
            y: -25
            text: "3.9-4.1V"
            text_color: 0xFFFF66
        - obj:
            align: BOTTOM_LEFT
            x: 275
            y: -30
            width: 8
            height: 8
            bg_color: 0x00FF00
            bg_opa: COVER
            border_width: 0
            radius: 0
        - label:
            align: BOTTOM_LEFT
            x: 287
            y: -25
            text: "3.2-3.9V"
            text_color: 0x66FF66
        - obj:
            align: BOTTOM_LEFT
            x: 340
            y: -30
            width: 8
            height: 8
            bg_color: 0x0066FF
            bg_opa: COVER
            border_width: 0
            radius: 0
        - label:
            align: BOTTOM_LEFT
            x: 352
            y: -25
            text: "<3.2V"
            text_color: 0x6666FF
        - obj:
            align: BOTTOM_LEFT
            x: 390
            y: -30
            width: 8
            height: 8
            bg_color: 0xFF8C00
            bg_opa: COVER
            border_width: 0
            radius: 0
        - label:
            align: BOTTOM_LEFT
            x: 402
            y: -25
            text: "Balancing"
            text_color: 0xFF8C00

# Binary sensors for system status
binary_sensor:
  - platform: status
    name: "Tesla BMS Display Status"
    id: display_status

# Sensors for system parameters
sensor:
  # System parameters
  - platform: template
    name: "Number of BMBs"
    id: numbmbs
    unit_of_measurement: "boards"
    accuracy_decimals: 0
    
  - platform: template
    name: "Loop Counter"
    id: loopcnt
    unit_of_measurement: "count"
    accuracy_decimals: 0
    
  - platform: template
    name: "Loop State"
    id: loopstate
    unit_of_measurement: "state"
    accuracy_decimals: 0
    
  - platform: template
    name: "Cells Present"
    id: cellspresent
    unit_of_measurement: "cells"
    accuracy_decimals: 0
    
  - platform: template
    name: "Cells Balancing"
    id: cellsbalancing
    unit_of_measurement: "cells"
    accuracy_decimals: 0

  # Voltage statistics
  - platform: template
    name: "Cell Max Number"
    id: cellmax
    unit_of_measurement: "cell"
    accuracy_decimals: 0
    
  - platform: template
    name: "Cell Min Number"
    id: cellmin
    unit_of_measurement: "cell"
    accuracy_decimals: 0
    
  - platform: template
    name: "Max Voltage"
    id: umax
    unit_of_measurement: "V"
    accuracy_decimals: 3
    
  - platform: template
    name: "Min Voltage"
    id: umin
    unit_of_measurement: "V"
    accuracy_decimals: 3
    
  - platform: template
    name: "Voltage Delta"
    id: deltav
    unit_of_measurement: "V"
    accuracy_decimals: 3
    
  - platform: template
    name: "Average Voltage"
    id: uavg
    unit_of_measurement: "V"
    accuracy_decimals: 3
    
  - platform: template
    name: "DC Voltage"
    id: udc
    unit_of_measurement: "V"
    accuracy_decimals: 2

  # Temperature sensors
  - platform: template
    name: "Chip Temperature"
    id: chipt0
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    
  - platform: template
    name: "Cell Temperature 0"
    id: cellt0_0
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    
  - platform: template
    name: "Cell Temperature 1"
    id: cellt0_1
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    
  - platform: template
    name: "Max Temperature"
    id: tempmax
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    
  - platform: template
    name: "Min Temperature"
    id: tempmin
    unit_of_measurement: "°C"
    accuracy_decimals: 1

  # Balance control
  - platform: template
    name: "Balance Status"
    id: balance
    unit_of_measurement: "status"
    accuracy_decimals: 0

# Text sensor for balance cell list
text_sensor:
  - platform: template
    name: "Balance Cell List"
    id: balance_cell_list

# Interval to periodically request parameters and update display
interval:
  # Fast interval to read and parse UART data
  - interval: 100ms
    then:
      - lambda: |-
          // Read available UART data
          std::string &buffer = id(uart_buffer);
          uint8_t data;
          while (id(tesla_bms_uart_uart).available()) {
            id(tesla_bms_uart_uart).read_byte(&data);
            char c = (char)data;
            if (c == '\n' || c == '\r') {
              if (!buffer.empty()) {
                ESP_LOGI("BMS", "RECEIVED: [%s] (length: %d)", buffer.c_str(), buffer.length());
                
                // Individual parameter requests return "param: value" format (colon + space)
                // Skip error messages, empty lines, and help text
                if (buffer.empty() || 
                    buffer.find("Error:") != std::string::npos ||
                    buffer.find("Unknown") != std::string::npos ||
                    buffer.find("===") != std::string::npos ||
                    buffer.find("Available") != std::string::npos ||
                    buffer.find_first_not_of("= -+*") == std::string::npos) {
                  ESP_LOGV("BMS", "Skipping non-parameter line: %s", buffer.c_str());
                } else {
                  // Parse the line in format "param: value" (BMS uses colon format)
                  size_t pos = buffer.find(": ");
                  if (pos != std::string::npos) {
                    std::string param = buffer.substr(0, pos);
                    std::string value_str = buffer.substr(pos + 2); // Skip ": "
                    
                    // Trim whitespace
                    param.erase(0, param.find_first_not_of(" \t\r\n"));
                    param.erase(param.find_last_not_of(" \t\r\n") + 1);
                    value_str.erase(0, value_str.find_first_not_of(" \t\r\n"));
                    value_str.erase(value_str.find_last_not_of(" \t\r\n") + 1);
                    
                    // Skip if parameter name is empty (header lines)
                    if (!param.empty()) {
                  
                                      // Debug: Show what we're trying to parse
                    ESP_LOGI("BMS", "PARSING: param='%s' value_str='%s' (from line: %s)", param.c_str(), value_str.c_str(), buffer.c_str());
                    
                    // Validate that value_str is not empty and looks like a number
                    if (!value_str.empty() && (isdigit(value_str[0]) || value_str[0] == '.' || value_str[0] == '-')) {
                      float value = atof(value_str.c_str());
                      ESP_LOGI("BMS", "PARSED VALUE: %s = %f", param.c_str(), value);
                  
                                        // Update corresponding sensors - All parameter names now match BMS exactly
                      // Note: Skip 5V (5000mV) initialization values to prevent sending misleading data to Home Assistant
                      bool sensor_updated = false;
                      if (param == "numbmbs") { id(numbmbs).publish_state(value); sensor_updated = true; }
                      else if (param == "LoopCnt") { id(loopcnt).publish_state(value); sensor_updated = true; }
                      else if (param == "LoopState") { id(loopstate).publish_state(value); sensor_updated = true; }
                      else if (param == "CellsPresent") { id(cellspresent).publish_state(value); sensor_updated = true; }
                      else if (param == "CellsBalancing") { id(cellsbalancing).publish_state(value); sensor_updated = true; }
                      else if (param == "CellMax") { id(cellmax).publish_state(value); sensor_updated = true; }
                      else if (param == "CellMin") { id(cellmin).publish_state(value); sensor_updated = true; }
                      else if (param == "umax") { 
                        // Check for 5V initialization value (5000mV) and publish NaN instead
                        if (value == 5000.0) {
                          ESP_LOGI("BMS", "Detected 5V initialization value for %s, publishing NaN", param.c_str());
                          // Don't publish the 5V initialization value - let it remain NaN until real data arrives
                        } else {
                          id(umax).publish_state(value / 1000.0); 
                        }
                        sensor_updated = true; 
                      }
                      else if (param == "umin") { 
                        // Check for 5V initialization value (5000mV) and publish NaN instead
                        if (value == 5000.0) {
                          ESP_LOGI("BMS", "Detected 5V initialization value for %s, publishing NaN", param.c_str());
                          // Don't publish the 5V initialization value - let it remain NaN until real data arrives
                        } else {
                          id(umin).publish_state(value / 1000.0); 
                        }
                        sensor_updated = true; 
                      }
                      else if (param == "deltaV") { id(deltav).publish_state(value / 1000.0); sensor_updated = true; }
                      else if (param == "uavg") { id(uavg).publish_state(value / 1000.0); sensor_updated = true; }
                      else if (param == "udc") { id(udc).publish_state(value); sensor_updated = true; }
                      else if (param == "Chipt0") { id(chipt0).publish_state(value); sensor_updated = true; }
                      else if (param == "Cellt0_0") { id(cellt0_0).publish_state(value); sensor_updated = true; }
                      else if (param == "Cellt0_1") { id(cellt0_1).publish_state(value); sensor_updated = true; }
                      else if (param == "TempMax") { id(tempmax).publish_state(value); sensor_updated = true; }
                      else if (param == "TempMin") { id(tempmin).publish_state(value); sensor_updated = true; }
                      else if (param == "balance") { id(balance).publish_state(value); sensor_updated = true; }
                      
                      // Handle special case for BalanceCellList (string parameter)
                      if (!sensor_updated && param == "BalanceCellList") {
                        // For string parameters, use the original value_str without converting to float
                        id(balance_cell_list).publish_state(value_str.c_str());
                        ESP_LOGI("BMS", "STRING SENSOR UPDATED: %s = %s", param.c_str(), value_str.c_str());
                        sensor_updated = true;
                      }
                      
                      // Individual cell voltages (u1-u108) - convert from mV to V, skip 5V initialization values
                      else if (param == "u1") { 
                        if (value == 5000.0) {
                          ESP_LOGI("BMS", "Skipping 5V initialization value for %s", param.c_str());
                        } else {
                          id(u1).publish_state(value / 1000.0); 
                        }
                        sensor_updated = true; 
                      }
                      else if (param == "u2") { 
                        if (value == 5000.0) {
                          ESP_LOGV("BMS", "Skipping 5V initialization value for %s", param.c_str());
                        } else {
                          id(u2).publish_state(value / 1000.0); 
                        }
                        sensor_updated = true; 
                      }
                      else if (param == "u3") { 
                        if (value == 5000.0) {
                          ESP_LOGV("BMS", "Skipping 5V initialization value for %s", param.c_str());
                        } else {
                          id(u3).publish_state(value / 1000.0); 
                        }
                        sensor_updated = true; 
                      }
                      else if (param == "u4") { 
                        if (value == 5000.0) {
                          ESP_LOGV("BMS", "Skipping 5V initialization value for %s", param.c_str());
                        } else {
                          id(u4).publish_state(value / 1000.0); 
                        }
                        sensor_updated = true; 
                      }
                      else if (param == "u5") { 
                        if (value == 5000.0) {
                          ESP_LOGV("BMS", "Skipping 5V initialization value for %s", param.c_str());
                        } else {
                          id(u5).publish_state(value / 1000.0); 
                        }
                        sensor_updated = true; 
                      }
                      else if (param == "u6") { 
                        if (value == 5000.0) {
                          ESP_LOGV("BMS", "Skipping 5V initialization value for %s", param.c_str());
                        } else {
                          id(u6).publish_state(value / 1000.0); 
                        }
                        sensor_updated = true; 
                      }
                      else if (param == "u7") { 
                        if (value == 5000.0) {
                          ESP_LOGV("BMS", "Skipping 5V initialization value for %s", param.c_str());
                        } else {
                          id(u7).publish_state(value / 1000.0); 
                        }
                        sensor_updated = true; 
                      }
                      else if (param == "u8") { 
                        if (value == 5000.0) {
                          ESP_LOGV("BMS", "Skipping 5V initialization value for %s", param.c_str());
                        } else {
                          id(u8).publish_state(value / 1000.0); 
                        }
                        sensor_updated = true; 
                      }
                      else if (param == "u9") { 
                        if (value == 5000.0) {
                          ESP_LOGV("BMS", "Skipping 5V initialization value for %s", param.c_str());
                        } else {
                          id(u9).publish_state(value / 1000.0); 
                        }
                        sensor_updated = true; 
                      }
                      else if (param == "u10") { 
                        if (value == 5000.0) {
                          ESP_LOGV("BMS", "Skipping 5V initialization value for %s", param.c_str());
                        } else {
                          id(u10).publish_state(value / 1000.0); 
                        }
                        sensor_updated = true; 
                      }
                      // Handle remaining cell voltages u11-u108 with 5V initialization check
                      else if (param.substr(0,1) == "u" && param.length() >= 2) {
                        // This handles all cell voltage parameters (u11, u12, ..., u108)
                        // Skip 5V initialization values (5000mV)
                        if (value == 5000.0) {
                          ESP_LOGV("BMS", "Skipping 5V initialization value for %s", param.c_str());
                          sensor_updated = true;
                        } else {
                          // Publish the voltage value converted from mV to V
                          float voltage_v = value / 1000.0;
                          
                          // Manually check each cell parameter and publish to corresponding sensor
                          if (param == "u11") { id(u11).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u12") { id(u12).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u13") { id(u13).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u14") { id(u14).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u15") { id(u15).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u16") { id(u16).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u17") { id(u17).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u18") { id(u18).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u19") { id(u19).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u20") { id(u20).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u21") { id(u21).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u22") { id(u22).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u23") { id(u23).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u24") { id(u24).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u25") { id(u25).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u26") { id(u26).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u27") { id(u27).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u28") { id(u28).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u29") { id(u29).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u30") { id(u30).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u31") { id(u31).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u32") { id(u32).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u33") { id(u33).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u34") { id(u34).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u35") { id(u35).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u36") { id(u36).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u37") { id(u37).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u38") { id(u38).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u39") { id(u39).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u40") { id(u40).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u41") { id(u41).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u42") { id(u42).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u43") { id(u43).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u44") { id(u44).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u45") { id(u45).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u46") { id(u46).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u47") { id(u47).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u48") { id(u48).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u49") { id(u49).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u50") { id(u50).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u51") { id(u51).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u52") { id(u52).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u53") { id(u53).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u54") { id(u54).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u55") { id(u55).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u56") { id(u56).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u57") { id(u57).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u58") { id(u58).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u59") { id(u59).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u60") { id(u60).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u61") { id(u61).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u62") { id(u62).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u63") { id(u63).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u64") { id(u64).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u65") { id(u65).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u66") { id(u66).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u67") { id(u67).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u68") { id(u68).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u69") { id(u69).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u70") { id(u70).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u71") { id(u71).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u72") { id(u72).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u73") { id(u73).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u74") { id(u74).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u75") { id(u75).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u76") { id(u76).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u77") { id(u77).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u78") { id(u78).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u79") { id(u79).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u80") { id(u80).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u81") { id(u81).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u82") { id(u82).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u83") { id(u83).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u84") { id(u84).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u85") { id(u85).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u86") { id(u86).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u87") { id(u87).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u88") { id(u88).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u89") { id(u89).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u90") { id(u90).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u91") { id(u91).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u92") { id(u92).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u93") { id(u93).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u94") { id(u94).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u95") { id(u95).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u96") { id(u96).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u97") { id(u97).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u98") { id(u98).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u99") { id(u99).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u100") { id(u100).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u101") { id(u101).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u102") { id(u102).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u103") { id(u103).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u104") { id(u104).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u105") { id(u105).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u106") { id(u106).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u107") { id(u107).publish_state(voltage_v); sensor_updated = true; }
                          else if (param == "u108") { id(u108).publish_state(voltage_v); sensor_updated = true; }
                        }
                      }
                      
                                             if (sensor_updated) {
                         ESP_LOGI("BMS", "SENSOR UPDATED: %s = %f", param.c_str(), value);
                       } else {
                         ESP_LOGW("BMS", "UNKNOWN PARAMETER: %s", param.c_str());
                       }
                      } else {
                        ESP_LOGW("BMS", "Invalid value for parameter %s: '%s'", param.c_str(), value_str.c_str());
                      }
                    } else {
                      ESP_LOGV("BMS", "Empty parameter name in line: %s", buffer.c_str());
                    }
                  } else {
                    ESP_LOGV("BMS", "Line without ': ' separator: %s", buffer.c_str());
                  }
                }
                buffer.clear();
              }
            } else {
              // Prevent buffer overflow - limit buffer size to reasonable length
              if (buffer.length() < 200) {
                buffer += c;
              } else {
                ESP_LOGW("BMS", "Buffer overflow, clearing buffer");
                buffer.clear();
              }
            }
          }
  
  # Slower interval for parameter requests and display updates
  - interval: 5s
    then:
      # Request system parameters
      - lambda: 'ESP_LOGI("BMS", "SENDING: param get numbmbs");'
      - uart.write:
          id: tesla_bms_uart_uart
          data: "param get numbmbs\n"
      - delay: 100ms
      - lambda: 'ESP_LOGI("BMS", "SENDING: param get LoopCnt");'
      - uart.write:
          id: tesla_bms_uart_uart
          data: "param get LoopCnt\n"
      - delay: 100ms
      - lambda: 'ESP_LOGI("BMS", "SENDING: param get LoopState");'
      - uart.write:
          id: tesla_bms_uart_uart
          data: "param get LoopState\n"
      - delay: 100ms
      - lambda: 'ESP_LOGI("BMS", "SENDING: param get CellsPresent");'
      - uart.write:
          id: tesla_bms_uart_uart
          data: "param get CellsPresent\n"
      - delay: 100ms
      - lambda: 'ESP_LOGI("BMS", "SENDING: param get CellsBalancing");'
      - uart.write:
          id: tesla_bms_uart_uart
          data: "param get CellsBalancing\n"
      - delay: 100ms
      
      # Request voltage parameters
      - lambda: 'ESP_LOGI("BMS", "SENDING: param get umax");'
      - uart.write:
          id: tesla_bms_uart_uart
          data: "param get umax\n"
      - delay: 100ms
      - lambda: 'ESP_LOGI("BMS", "SENDING: param get umin");'
      - uart.write:
          id: tesla_bms_uart_uart
          data: "param get umin\n"
      - delay: 100ms
      - lambda: 'ESP_LOGI("BMS", "SENDING: param get deltaV");'
      - uart.write:
          id: tesla_bms_uart_uart
          data: "param get deltaV\n"
      - delay: 100ms
      - lambda: 'ESP_LOGI("BMS", "SENDING: param get uavg");'
      - uart.write:
          id: tesla_bms_uart_uart
          data: "param get uavg\n"
      - delay: 100ms
      - lambda: 'ESP_LOGI("BMS", "SENDING: param get udc");'
      - uart.write:
          id: tesla_bms_uart_uart
          data: "param get udc\n"
      - delay: 100ms
      - lambda: 'ESP_LOGI("BMS", "SENDING: param get CellMax");'
      - uart.write:
          id: tesla_bms_uart_uart
          data: "param get CellMax\n"
      - delay: 100ms
      - lambda: 'ESP_LOGI("BMS", "SENDING: param get CellMin");'
      - uart.write:
          id: tesla_bms_uart_uart
          data: "param get CellMin\n"
      - delay: 100ms
      
      # Request temperature parameters
      - lambda: 'ESP_LOGI("BMS", "SENDING: param get Chipt0");'
      - uart.write:
          id: tesla_bms_uart_uart
          data: "param get Chipt0\n"
      - delay: 100ms
      - lambda: 'ESP_LOGI("BMS", "SENDING: param get Cellt0_0");'
      - uart.write:
          id: tesla_bms_uart_uart
          data: "param get Cellt0_0\n"
      - delay: 100ms
      - lambda: 'ESP_LOGI("BMS", "SENDING: param get Cellt0_1");'
      - uart.write:
          id: tesla_bms_uart_uart
          data: "param get Cellt0_1\n"
      - delay: 100ms
      - lambda: 'ESP_LOGI("BMS", "SENDING: param get TempMax");'
      - uart.write:
          id: tesla_bms_uart_uart
          data: "param get TempMax\n"
      - delay: 100ms
      - lambda: 'ESP_LOGI("BMS", "SENDING: param get TempMin");'
      - uart.write:
          id: tesla_bms_uart_uart
          data: "param get TempMin\n"
      - delay: 100ms
      
      # Request balance status
      - lambda: 'ESP_LOGI("BMS", "SENDING: param get balance");'
      - uart.write:
          id: tesla_bms_uart_uart
          data: "param get balance\n"
      - delay: 100ms
      
      # Request balance cell list
      - lambda: 'ESP_LOGI("BMS", "SENDING: param get BalanceCellList");'
      - uart.write:
          id: tesla_bms_uart_uart
          data: "param get BalanceCellList\n"
      - delay: 100ms

  # Separate faster interval for individual cell voltage requests (every 10 seconds)
  - interval: 10s
    then:
      # Request individual cell voltages in batches to avoid overwhelming the system
      # Batch 1: Cells 1-20
      - lambda: 'ESP_LOGI("BMS", "REQUESTING: Cell voltages batch 1 (u1-u20)");'
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u1\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u2\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u3\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u4\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u5\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u6\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u7\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u8\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u9\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u10\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u11\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u12\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u13\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u14\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u15\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u16\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u17\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u18\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u19\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u20\n" }
      - delay: 500ms  # Longer delay between batches

  # Batch 2: Cells 21-40 (offset by 2s)
  - interval: 10s
    then:
      - delay: 2s  # Offset to spread requests
      - lambda: 'ESP_LOGI("BMS", "REQUESTING: Cell voltages batch 2 (u21-u40)");'
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u21\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u22\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u23\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u24\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u25\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u26\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u27\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u28\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u29\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u30\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u31\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u32\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u33\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u34\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u35\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u36\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u37\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u38\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u39\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u40\n" }
      - delay: 500ms

  # Batch 3: Cells 41-60 (offset by 4s)
  - interval: 10s
    then:
      - delay: 4s
      - lambda: 'ESP_LOGI("BMS", "REQUESTING: Cell voltages batch 3 (u41-u60)");'
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u41\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u42\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u43\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u44\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u45\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u46\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u47\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u48\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u49\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u50\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u51\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u52\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u53\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u54\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u55\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u56\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u57\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u58\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u59\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u60\n" }
      - delay: 500ms

  # Batch 4: Cells 61-80 (offset by 6s)
  - interval: 10s
    then:
      - delay: 6s
      - lambda: 'ESP_LOGI("BMS", "REQUESTING: Cell voltages batch 4 (u61-u80)");'
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u61\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u62\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u63\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u64\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u65\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u66\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u67\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u68\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u69\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u70\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u71\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u72\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u73\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u74\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u75\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u76\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u77\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u78\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u79\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u80\n" }
      - delay: 500ms

  # Batch 5: Cells 81-100 (offset by 8s)
  - interval: 10s
    then:
      - delay: 8s
      - lambda: 'ESP_LOGI("BMS", "REQUESTING: Cell voltages batch 5 (u81-u100)");'
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u81\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u82\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u83\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u84\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u85\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u86\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u87\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u88\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u89\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u90\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u91\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u92\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u93\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u94\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u95\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u96\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u97\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u98\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u99\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u100\n" }
      - delay: 500ms

  # Batch 6: Cells 101-108 (offset by 9s)
  - interval: 10s
    then:
      - delay: 9s
      - lambda: 'ESP_LOGI("BMS", "REQUESTING: Cell voltages batch 6 (u101-u108)");'
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u101\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u102\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u103\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u104\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u105\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u106\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u107\n" }
      - delay: 50ms
      - uart.write: { id: tesla_bms_uart_uart, data: "param get u108\n" }
      - delay: 50ms
      - lambda: |-
          // Update display labels with current sensor values
          char buffer[64];
          
          // Update cells info - show BMB count since individual cell counts aren't available
          if (id(numbmbs).has_state()) {
            snprintf(buffer, sizeof(buffer), "BMBs: %d (Bal: %s)", 
                     (int)id(numbmbs).state, 
                     (id(balance).has_state() && id(balance).state > 0.5) ? "ON" : "OFF");
          } else {
            snprintf(buffer, sizeof(buffer), "BMBs: -- (Bal: --)");
          }
          lv_label_set_text((lv_obj_t*)id(label_cells), buffer);
          
          // Update balance status
          if (id(balance).has_state() && id(balance).state > 0.5) {
            lv_label_set_text((lv_obj_t*)id(label_balance), "Balance: ON");
            lv_obj_set_style_text_color((lv_obj_t*)id(label_balance), lv_color_make(0, 255, 0), LV_PART_MAIN); // Green
          } else {
            lv_label_set_text((lv_obj_t*)id(label_balance), "Balance: OFF");
            lv_obj_set_style_text_color((lv_obj_t*)id(label_balance), lv_color_make(255, 0, 0), LV_PART_MAIN); // Red
          }
          
          // Update voltage info - check for valid data
          if (id(umax).has_state() && id(cellmax).has_state()) {
            snprintf(buffer, sizeof(buffer), "Max: %.3fV (Cell %d)", 
                     id(umax).state, (int)id(cellmax).state);
          } else {
            snprintf(buffer, sizeof(buffer), "Max: --.---V (Cell --)");
          }
          lv_label_set_text((lv_obj_t*)id(label_max_voltage), buffer);
          
          if (id(umin).has_state() && id(cellmin).has_state()) {
            snprintf(buffer, sizeof(buffer), "Min: %.3fV (Cell %d)", 
                     id(umin).state, (int)id(cellmin).state);
          } else {
            snprintf(buffer, sizeof(buffer), "Min: --.---V (Cell --)");
          }
          lv_label_set_text((lv_obj_t*)id(label_min_voltage), buffer);
          
          if (id(deltav).has_state()) {
            snprintf(buffer, sizeof(buffer), "Delta: %.3fV", 
                     id(deltav).state);
          } else {
            snprintf(buffer, sizeof(buffer), "Delta: --.---V");
          }
          lv_label_set_text((lv_obj_t*)id(label_delta), buffer);
          
          // Update temperature - check for valid data
          if (id(chipt0).has_state()) {
            snprintf(buffer, sizeof(buffer), "Temp: %.1f°C", 
                     id(chipt0).state);
          } else {
            snprintf(buffer, sizeof(buffer), "Temp: --.--°C");
          }
          lv_label_set_text((lv_obj_t*)id(label_temp), buffer);
          
          // Update loop info - check for valid data
          if (id(loopcnt).has_state() && id(loopstate).has_state()) {
            snprintf(buffer, sizeof(buffer), "Loop: %d (State: %d)", 
                     (int)id(loopcnt).state, (int)id(loopstate).state);
          } else {
            snprintf(buffer, sizeof(buffer), "Loop: -- (State: --)");
          }
          lv_label_set_text((lv_obj_t*)id(label_loop), buffer);
          
          // Update connection status
          if (id(display_status).state) {
            lv_label_set_text((lv_obj_t*)id(label_connected), "Connected: Yes");
            lv_obj_set_style_text_color((lv_obj_t*)id(label_connected), lv_color_make(0, 255, 0), LV_PART_MAIN); // Green
          } else {
            lv_label_set_text((lv_obj_t*)id(label_connected), "Connected: No");
            lv_obj_set_style_text_color((lv_obj_t*)id(label_connected), lv_color_make(255, 0, 0), LV_PART_MAIN); // Red
          }
          
          // Update time
          auto time = id(sntp_time).now();
          if (time.is_valid()) {
            snprintf(buffer, sizeof(buffer), "%02d:%02d:%02d", 
                     time.hour, time.minute, time.second);
            lv_label_set_text((lv_obj_t*)id(label_time), buffer);
            lv_label_set_text((lv_obj_t*)id(label_cells_time), buffer);
          }
          
          // Update second page (Battery Details) labels
          // Average voltage
          if (id(uavg).has_state()) {
            snprintf(buffer, sizeof(buffer), "Avg: %.3fV", id(uavg).state);
          } else {
            snprintf(buffer, sizeof(buffer), "Avg: --.---V");
          }
          lv_label_set_text((lv_obj_t*)id(label_avg_voltage), buffer);
          
          // DC voltage
          if (id(udc).has_state()) {
            snprintf(buffer, sizeof(buffer), "DC: %.2fV", id(udc).state);
          } else {
            snprintf(buffer, sizeof(buffer), "DC: --.--V");
          }
          lv_label_set_text((lv_obj_t*)id(label_dc_voltage), buffer);
          
          // Cells present and balancing
          if (id(cellspresent).has_state()) {
            snprintf(buffer, sizeof(buffer), "Cells: %d", (int)id(cellspresent).state);
          } else {
            snprintf(buffer, sizeof(buffer), "Cells: --");
          }
          lv_label_set_text((lv_obj_t*)id(label_cells_present), buffer);
          
          if (id(cellsbalancing).has_state()) {
            snprintf(buffer, sizeof(buffer), "Balancing: %d", (int)id(cellsbalancing).state);
          } else {
            snprintf(buffer, sizeof(buffer), "Balancing: --");
          }
          lv_label_set_text((lv_obj_t*)id(label_cells_balancing), buffer);
          
          // Temperature sensors
          if (id(chipt0).has_state()) {
            snprintf(buffer, sizeof(buffer), "Chip: %.1f°C", id(chipt0).state);
          } else {
            snprintf(buffer, sizeof(buffer), "Chip: --°C");
          }
          lv_label_set_text((lv_obj_t*)id(label_chip_temp), buffer);
          
          if (id(cellt0_0).has_state()) {
            snprintf(buffer, sizeof(buffer), "Cell0: %.1f°C", id(cellt0_0).state);
          } else {
            snprintf(buffer, sizeof(buffer), "Cell0: --°C");
          }
          lv_label_set_text((lv_obj_t*)id(label_cell_temp0), buffer);
          
          if (id(cellt0_1).has_state()) {
            snprintf(buffer, sizeof(buffer), "Cell1: %.1f°C", id(cellt0_1).state);
          } else {
            snprintf(buffer, sizeof(buffer), "Cell1: --°C");
          }
          lv_label_set_text((lv_obj_t*)id(label_cell_temp1), buffer);
          
          // Temperature range
          if (id(tempmax).has_state() && id(tempmin).has_state()) {
            float temp_delta = id(tempmax).state - id(tempmin).state;
            snprintf(buffer, sizeof(buffer), "Range: %.1f°C", temp_delta);
          } else {
            snprintf(buffer, sizeof(buffer), "Range: --°C");
          }
          lv_label_set_text((lv_obj_t*)id(label_temp_range), buffer);
          
          // BMB count
          if (id(numbmbs).has_state()) {
            snprintf(buffer, sizeof(buffer), "BMBs: %d", (int)id(numbmbs).state);
          } else {
            snprintf(buffer, sizeof(buffer), "BMBs: --");
          }
          lv_label_set_text((lv_obj_t*)id(label_bmb_count), buffer);
          
          // Loop details
          if (id(loopcnt).has_state()) {
            snprintf(buffer, sizeof(buffer), "Loop: %d", (int)id(loopcnt).state);
          } else {
            snprintf(buffer, sizeof(buffer), "Loop: --");
          }
          lv_label_set_text((lv_obj_t*)id(label_loop_details), buffer);
          
          // Balance status on details page
          if (id(balance).has_state() && id(balance).state > 0.5) {
            lv_label_set_text((lv_obj_t*)id(label_balance_status), "Balance: ON");
            lv_obj_set_style_text_color((lv_obj_t*)id(label_balance_status), lv_color_make(0, 255, 0), LV_PART_MAIN);
          } else {
            lv_label_set_text((lv_obj_t*)id(label_balance_status), "Balance: OFF");
            lv_obj_set_style_text_color((lv_obj_t*)id(label_balance_status), lv_color_make(255, 0, 0), LV_PART_MAIN);
          }
          
          // System state
          if (id(loopstate).has_state()) {
            snprintf(buffer, sizeof(buffer), "State: %d", (int)id(loopstate).state);
          } else {
            snprintf(buffer, sizeof(buffer), "State: --");
          }
          lv_label_set_text((lv_obj_t*)id(label_system_status), buffer);
          
          // Create and update cell voltage bars on cells page
          if (!id(cell_bars_created)) {
            // Create 108 cell voltage bars (3px wide, 180px max height, 3V-4.2V scale)
            lv_obj_t* container = (lv_obj_t*)id(cells_container);
            if (container) {
              for (int i = 0; i < 108; i++) {
                // Create voltage bar
                lv_obj_t* bar = lv_obj_create(container);
                lv_obj_set_size(bar, 3, 2); // Start with minimal height
                lv_obj_set_pos(bar, i * 4, 178); // Position at bottom (180-2)
                lv_obj_set_style_bg_color(bar, lv_color_make(100, 100, 100), LV_PART_MAIN);
                lv_obj_set_style_bg_opa(bar, LV_OPA_COVER, LV_PART_MAIN);
                lv_obj_set_style_border_width(bar, 0, LV_PART_MAIN);
                lv_obj_set_style_radius(bar, 0, LV_PART_MAIN);
                lv_obj_set_style_pad_all(bar, 0, LV_PART_MAIN);
              }
              id(cell_bars_created) = true;
              ESP_LOGI("DISPLAY", "Created 108 cell voltage bars");
            }
          }
          
          // Update cell voltage bars with current values (all 108 cells)
          lv_obj_t* container = (lv_obj_t*)id(cells_container);
          if (container && lv_obj_get_child_cnt(container) >= 108) {
            // Array of cell voltage sensors - collect all 108 cells, use actual BMS values (including 0V)
            std::vector<std::pair<int, float>> cell_data;
            
            // Cells 1-20 - Use NaN for uninitialized sensors to avoid showing misleading 0V or 5V values
            cell_data.push_back({0, id(u1).has_state() ? id(u1).state : NAN});
            cell_data.push_back({1, id(u2).has_state() ? id(u2).state : NAN});
            cell_data.push_back({2, id(u3).has_state() ? id(u3).state : NAN});
            cell_data.push_back({3, id(u4).has_state() ? id(u4).state : NAN});
            cell_data.push_back({4, id(u5).has_state() ? id(u5).state : NAN});
            cell_data.push_back({5, id(u6).has_state() ? id(u6).state : NAN});
            cell_data.push_back({6, id(u7).has_state() ? id(u7).state : NAN});
            cell_data.push_back({7, id(u8).has_state() ? id(u8).state : NAN});
            cell_data.push_back({8, id(u9).has_state() ? id(u9).state : NAN});
            cell_data.push_back({9, id(u10).has_state() ? id(u10).state : NAN});
            cell_data.push_back({10, id(u11).has_state() ? id(u11).state : 0.0f});
            cell_data.push_back({11, id(u12).has_state() ? id(u12).state : 0.0f});
            cell_data.push_back({12, id(u13).has_state() ? id(u13).state : 0.0f});
            cell_data.push_back({13, id(u14).has_state() ? id(u14).state : 0.0f});
            cell_data.push_back({14, id(u15).has_state() ? id(u15).state : 0.0f});
            cell_data.push_back({15, id(u16).has_state() ? id(u16).state : 0.0f});
            cell_data.push_back({16, id(u17).has_state() ? id(u17).state : 0.0f});
            cell_data.push_back({17, id(u18).has_state() ? id(u18).state : 0.0f});
            cell_data.push_back({18, id(u19).has_state() ? id(u19).state : 0.0f});
            cell_data.push_back({19, id(u20).has_state() ? id(u20).state : 0.0f});
            
            // Cells 21-40
            cell_data.push_back({20, id(u21).has_state() ? id(u21).state : 0.0f});
            cell_data.push_back({21, id(u22).has_state() ? id(u22).state : 0.0f});
            cell_data.push_back({22, id(u23).has_state() ? id(u23).state : 0.0f});
            cell_data.push_back({23, id(u24).has_state() ? id(u24).state : 0.0f});
            cell_data.push_back({24, id(u25).has_state() ? id(u25).state : 0.0f});
            cell_data.push_back({25, id(u26).has_state() ? id(u26).state : 0.0f});
            cell_data.push_back({26, id(u27).has_state() ? id(u27).state : 0.0f});
            cell_data.push_back({27, id(u28).has_state() ? id(u28).state : 0.0f});
            cell_data.push_back({28, id(u29).has_state() ? id(u29).state : 0.0f});
            cell_data.push_back({29, id(u30).has_state() ? id(u30).state : 0.0f});
            cell_data.push_back({30, id(u31).has_state() ? id(u31).state : 0.0f});
            cell_data.push_back({31, id(u32).has_state() ? id(u32).state : 0.0f});
            cell_data.push_back({32, id(u33).has_state() ? id(u33).state : 0.0f});
            cell_data.push_back({33, id(u34).has_state() ? id(u34).state : 0.0f});
            cell_data.push_back({34, id(u35).has_state() ? id(u35).state : 0.0f});
            cell_data.push_back({35, id(u36).has_state() ? id(u36).state : 0.0f});
            cell_data.push_back({36, id(u37).has_state() ? id(u37).state : 0.0f});
            cell_data.push_back({37, id(u38).has_state() ? id(u38).state : 0.0f});
            cell_data.push_back({38, id(u39).has_state() ? id(u39).state : 0.0f});
            cell_data.push_back({39, id(u40).has_state() ? id(u40).state : 0.0f});
            
            // Cells 41-60
            cell_data.push_back({40, id(u41).has_state() ? id(u41).state : 0.0f});
            cell_data.push_back({41, id(u42).has_state() ? id(u42).state : 0.0f});
            cell_data.push_back({42, id(u43).has_state() ? id(u43).state : 0.0f});
            cell_data.push_back({43, id(u44).has_state() ? id(u44).state : 0.0f});
            cell_data.push_back({44, id(u45).has_state() ? id(u45).state : 0.0f});
            cell_data.push_back({45, id(u46).has_state() ? id(u46).state : 0.0f});
            cell_data.push_back({46, id(u47).has_state() ? id(u47).state : 0.0f});
            cell_data.push_back({47, id(u48).has_state() ? id(u48).state : 0.0f});
            cell_data.push_back({48, id(u49).has_state() ? id(u49).state : 0.0f});
            cell_data.push_back({49, id(u50).has_state() ? id(u50).state : 0.0f});
            cell_data.push_back({50, id(u51).has_state() ? id(u51).state : 0.0f});
            cell_data.push_back({51, id(u52).has_state() ? id(u52).state : 0.0f});
            cell_data.push_back({52, id(u53).has_state() ? id(u53).state : 0.0f});
            cell_data.push_back({53, id(u54).has_state() ? id(u54).state : 0.0f});
            cell_data.push_back({54, id(u55).has_state() ? id(u55).state : 0.0f});
            cell_data.push_back({55, id(u56).has_state() ? id(u56).state : 0.0f});
            cell_data.push_back({56, id(u57).has_state() ? id(u57).state : 0.0f});
            cell_data.push_back({57, id(u58).has_state() ? id(u58).state : 0.0f});
            cell_data.push_back({58, id(u59).has_state() ? id(u59).state : 0.0f});
            cell_data.push_back({59, id(u60).has_state() ? id(u60).state : 0.0f});
            
            // Cells 61-80
            cell_data.push_back({60, id(u61).has_state() ? id(u61).state : 0.0f});
            cell_data.push_back({61, id(u62).has_state() ? id(u62).state : 0.0f});
            cell_data.push_back({62, id(u63).has_state() ? id(u63).state : 0.0f});
            cell_data.push_back({63, id(u64).has_state() ? id(u64).state : 0.0f});
            cell_data.push_back({64, id(u65).has_state() ? id(u65).state : 0.0f});
            cell_data.push_back({65, id(u66).has_state() ? id(u66).state : 0.0f});
            cell_data.push_back({66, id(u67).has_state() ? id(u67).state : 0.0f});
            cell_data.push_back({67, id(u68).has_state() ? id(u68).state : 0.0f});
            cell_data.push_back({68, id(u69).has_state() ? id(u69).state : 0.0f});
            cell_data.push_back({69, id(u70).has_state() ? id(u70).state : 0.0f});
            cell_data.push_back({70, id(u71).has_state() ? id(u71).state : 0.0f});
            cell_data.push_back({71, id(u72).has_state() ? id(u72).state : 0.0f});
            cell_data.push_back({72, id(u73).has_state() ? id(u73).state : 0.0f});
            cell_data.push_back({73, id(u74).has_state() ? id(u74).state : 0.0f});
            cell_data.push_back({74, id(u75).has_state() ? id(u75).state : 0.0f});
            cell_data.push_back({75, id(u76).has_state() ? id(u76).state : 0.0f});
            cell_data.push_back({76, id(u77).has_state() ? id(u77).state : 0.0f});
            cell_data.push_back({77, id(u78).has_state() ? id(u78).state : 0.0f});
            cell_data.push_back({78, id(u79).has_state() ? id(u79).state : 0.0f});
            cell_data.push_back({79, id(u80).has_state() ? id(u80).state : 0.0f});
            
            // Cells 81-100
            cell_data.push_back({80, id(u81).has_state() ? id(u81).state : 0.0f});
            cell_data.push_back({81, id(u82).has_state() ? id(u82).state : 0.0f});
            cell_data.push_back({82, id(u83).has_state() ? id(u83).state : 0.0f});
            cell_data.push_back({83, id(u84).has_state() ? id(u84).state : 0.0f});
            cell_data.push_back({84, id(u85).has_state() ? id(u85).state : 0.0f});
            cell_data.push_back({85, id(u86).has_state() ? id(u86).state : 0.0f});
            cell_data.push_back({86, id(u87).has_state() ? id(u87).state : 0.0f});
            cell_data.push_back({87, id(u88).has_state() ? id(u88).state : 0.0f});
            cell_data.push_back({88, id(u89).has_state() ? id(u89).state : 0.0f});
            cell_data.push_back({89, id(u90).has_state() ? id(u90).state : 0.0f});
            cell_data.push_back({90, id(u91).has_state() ? id(u91).state : 0.0f});
            cell_data.push_back({91, id(u92).has_state() ? id(u92).state : 0.0f});
            cell_data.push_back({92, id(u93).has_state() ? id(u93).state : 0.0f});
            cell_data.push_back({93, id(u94).has_state() ? id(u94).state : 0.0f});
            cell_data.push_back({94, id(u95).has_state() ? id(u95).state : 0.0f});
            cell_data.push_back({95, id(u96).has_state() ? id(u96).state : 0.0f});
            cell_data.push_back({96, id(u97).has_state() ? id(u97).state : 0.0f});
            cell_data.push_back({97, id(u98).has_state() ? id(u98).state : 0.0f});
            cell_data.push_back({98, id(u99).has_state() ? id(u99).state : 0.0f});
            cell_data.push_back({99, id(u100).has_state() ? id(u100).state : 0.0f});
            
            // Cells 101-108
            cell_data.push_back({100, id(u101).has_state() ? id(u101).state : 0.0f});
            cell_data.push_back({101, id(u102).has_state() ? id(u102).state : 0.0f});
            cell_data.push_back({102, id(u103).has_state() ? id(u103).state : 0.0f});
            cell_data.push_back({103, id(u104).has_state() ? id(u104).state : 0.0f});
            cell_data.push_back({104, id(u105).has_state() ? id(u105).state : 0.0f});
            cell_data.push_back({105, id(u106).has_state() ? id(u106).state : 0.0f});
            cell_data.push_back({106, id(u107).has_state() ? id(u107).state : 0.0f});
            cell_data.push_back({107, id(u108).has_state() ? id(u108).state : 0.0f});
            
            // Get balance cell list from the BMS (exact cell numbers being balanced)
            std::vector<int> balancing_cells;
            if (id(balance_cell_list).has_state() && id(balance).has_state() && id(balance).state > 0.5) {
              std::string balance_list = id(balance_cell_list).state;
              if (!balance_list.empty()) {
                // Parse comma-separated list of cell numbers (manual parsing to avoid sstream dependency)
                size_t start = 0;
                size_t end = 0;
                while ((end = balance_list.find(',', start)) != std::string::npos) {
                  std::string cell_num_str = balance_list.substr(start, end - start);
                  int cell_num = std::atoi(cell_num_str.c_str());
                  if (cell_num > 0 && cell_num <= 108) {
                    balancing_cells.push_back(cell_num - 1); // Convert to 0-based index
                  }
                  start = end + 1;
                }
                // Handle the last cell number (after the last comma or if no comma)
                if (start < balance_list.length()) {
                  std::string cell_num_str = balance_list.substr(start);
                  int cell_num = std::atoi(cell_num_str.c_str());
                  if (cell_num > 0 && cell_num <= 108) {
                    balancing_cells.push_back(cell_num - 1); // Convert to 0-based index
                  }
                }
                ESP_LOGI("DISPLAY", "Balance cells from BMS: %s", balance_list.c_str());
              }
            }
            
            // Update bars for all 108 cells
            for (auto& cell : cell_data) {
              int cell_idx = cell.first;
              float voltage = cell.second;
              
              if (cell_idx < lv_obj_get_child_cnt(container)) {
                lv_obj_t* bar = lv_obj_get_child(container, cell_idx);
                if (bar) {
                  // Handle NaN values (uninitialized sensors) - show minimal bar with gray color
                  if (std::isnan(voltage)) {
                    lv_obj_set_size(bar, 3, 2);
                    lv_obj_set_pos(bar, cell_idx * 4, 178);
                    lv_obj_set_style_bg_color(bar, lv_color_make(100, 100, 100), LV_PART_MAIN); // Gray for no data
                    lv_obj_set_style_border_width(bar, 0, LV_PART_MAIN);
                    continue; // Skip rest of processing for this cell
                  }
                  
                  // Map voltage to bar height - scale matches visual grid lines exactly
                  voltage = std::max(0.0f, std::min(4.2f, voltage)); // Clamp to range (allow 0V)
                  int base_height;
                  if (voltage < 3.0f) {
                    // For voltages below 3.0V (including 0V), scale from 2-10px height
                    base_height = (int)(voltage / 3.0f * 8.0f) + 2;
                  } else {
                    // For normal voltages (3.0-4.2V), map to bar height correctly
                    // 3.0V = 0px height (at bottom), 4.2V = 180px height (full height)
                    base_height = (int)((voltage - 3.0f) / 1.2f * 180.0f);
                  }
                  
                  // Check if this cell is in the balancing list
                  bool cell_balancing = std::find(balancing_cells.begin(), balancing_cells.end(), cell_idx) != balancing_cells.end();
                  
                  int total_height, y_pos;
                  if (cell_balancing) {
                    // Extend bar below graph with blue indicator (extra 8px below)
                    total_height = base_height + 8;
                    y_pos = 180 - base_height;
                  } else {
                    // Normal bar height
                    total_height = base_height;
                    y_pos = 180 - base_height;
                  }
                  
                  lv_obj_set_size(bar, 3, total_height);
                  lv_obj_set_pos(bar, cell_idx * 4, y_pos);
                  
                  // Remove any borders (no longer needed)
                  lv_obj_set_style_border_width(bar, 0, LV_PART_MAIN);
                  
                  if (cell_balancing) {
                    // For balancing cells, use bright orange to distinguish from voltage status
                    lv_obj_set_style_bg_color(bar, lv_color_make(255, 140, 0), LV_PART_MAIN);
                  } else {
                    // Standard voltage color coding for non-balancing cells
                    if (voltage > 4.1f) {
                      lv_obj_set_style_bg_color(bar, lv_color_make(255, 0, 0), LV_PART_MAIN);
                    } else if (voltage > 3.9f) {
                      lv_obj_set_style_bg_color(bar, lv_color_make(255, 255, 0), LV_PART_MAIN);
                    } else if (voltage > 3.2f) {
                      lv_obj_set_style_bg_color(bar, lv_color_make(0, 255, 0), LV_PART_MAIN);
                    } else {
                      lv_obj_set_style_bg_color(bar, lv_color_make(0, 100, 255), LV_PART_MAIN);
                    }
                  }
                }
              }
            }
            
            ESP_LOGI("DISPLAY", "Updated all 108 cell voltage bars (real BMS data)");
          }

font:
  - file: "gfonts://Montserrat"
    id: montserrat_14
    size: 14